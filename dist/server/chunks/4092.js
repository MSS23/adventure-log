"use strict";exports.id=4092,exports.ids=[4092],exports.modules={44092:(a,b,c)=>{c.r(b),c.d(b,{FilesystemWeb:()=>g});var d=c(1022),e=c(79416);function f(a){let b=a.split("/").filter(a=>"."!==a),c=[];return b.forEach(a=>{".."===a&&c.length>0&&".."!==c[c.length-1]?c.pop():c.push(a)}),c.join("/")}class g extends d.E_{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async a=>{var b,c;let e,f=(0,d.EA)(a,a.webFetchExtra),g=await fetch(a.url,f);if(a.progress)if(null==g?void 0:g.body){let b=g.body.getReader(),c=0,d=[],f=g.headers.get("content-type"),h=parseInt(g.headers.get("content-length")||"0",10);for(;;){let{done:e,value:f}=await b.read();if(e)break;d.push(f),c+=(null==f?void 0:f.length)||0;let g={url:a.url,bytes:c,contentLength:h};this.notifyListeners("progress",g)}let i=new Uint8Array(c),j=0;for(let a of d)void 0!==a&&(i.set(a,j),j+=a.length);e=new Blob([i.buffer],{type:f||void 0})}else e=new Blob;else e=await g.blob();return{path:(await this.writeFile({path:a.path,directory:null!=(b=a.directory)?b:void 0,recursive:null!=(c=a.recursive)&&c,data:e})).uri,blob:e}}}readFileInChunks(a,b){throw this.unavailable("Method not implemented.")}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((a,b)=>{let c=indexedDB.open(this.DB_NAME,this.DB_VERSION);c.onupgradeneeded=g.doUpgrade,c.onsuccess=()=>{this._db=c.result,a(c.result)},c.onerror=()=>b(c.error),c.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(a){let b=a.target.result;a.oldVersion,b.objectStoreNames.contains("FileStorage")&&b.deleteObjectStore("FileStorage"),b.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(a,b){let c=-1!==this._writeCmds.indexOf(a)?"readwrite":"readonly";return this.initDb().then(d=>new Promise((e,f)=>{let g=d.transaction(["FileStorage"],c).objectStore("FileStorage")[a](...b);g.onsuccess=()=>e(g.result),g.onerror=()=>f(g.error)}))}async dbIndexRequest(a,b,c){let d=-1!==this._writeCmds.indexOf(b)?"readwrite":"readonly";return this.initDb().then(e=>new Promise((f,g)=>{let h=e.transaction(["FileStorage"],d).objectStore("FileStorage").index(a)[b](...c);h.onsuccess=()=>f(h.result),h.onerror=()=>g(h.error)}))}getPath(a,b){let c=void 0!==b?b.replace(/^[/]+|[/]+$/g,""):"",d="";return void 0!==a&&(d+="/"+a),""!==b&&(d+="/"+c),d}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(void 0===c)throw Error("File does not exist.");return{data:c.content?c.content:""}}async writeFile(a){let b=this.getPath(a.directory,a.path),c=a.data,d=a.encoding,e=a.recursive,f=await this.dbRequest("get",[b]);if(f&&"directory"===f.type)throw Error("The supplied path is a directory.");let g=b.substr(0,b.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[g])){let b=g.indexOf("/",1);if(-1!==b){let c=g.substr(b);await this.mkdir({path:c,directory:a.directory,recursive:e})}}if(!d&&!(c instanceof Blob)&&(c=c.indexOf(",")>=0?c.split(",")[1]:c,!this.isBase64String(c)))throw Error("The supplied data is not valid base64 content.");let h=Date.now(),i={path:b,folder:g,type:"file",size:c instanceof Blob?c.size:c.length,ctime:h,mtime:h,content:c};return await this.dbRequest("put",[i]),{uri:i.path}}async appendFile(a){let b=this.getPath(a.directory,a.path),c=a.data,d=a.encoding,e=b.substr(0,b.lastIndexOf("/")),f=Date.now(),g=f,h=await this.dbRequest("get",[b]);if(h&&"directory"===h.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[e])){let b=e.indexOf("/",1);if(-1!==b){let c=e.substr(b);await this.mkdir({path:c,directory:a.directory,recursive:!0})}}if(!d&&!this.isBase64String(c))throw Error("The supplied data is not valid base64 content.");if(void 0!==h){if(h.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");c=void 0===h.content||d?h.content+c:btoa(atob(h.content)+atob(c)),g=h.ctime}let i={path:b,folder:e,type:"file",size:c.length,ctime:g,mtime:f,content:c};await this.dbRequest("put",[i])}async deleteFile(a){let b=this.getPath(a.directory,a.path);if(void 0===await this.dbRequest("get",[b]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(b)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[b])}async mkdir(a){let b=this.getPath(a.directory,a.path),c=a.recursive,d=b.substr(0,b.lastIndexOf("/")),e=(b.match(/\//g)||[]).length,f=await this.dbRequest("get",[d]),g=await this.dbRequest("get",[b]);if(1===e)throw Error("Cannot create Root directory");if(void 0!==g)throw Error("Current directory does already exist.");if(!c&&2!==e&&void 0===f)throw Error("Parent directory must exist");if(c&&2!==e&&void 0===f){let b=d.substr(d.indexOf("/",1));await this.mkdir({path:b,directory:a.directory,recursive:c})}let h=Date.now();await this.dbRequest("put",[{path:b,folder:d,type:"directory",size:0,ctime:h,mtime:h}])}async rmdir(a){let{path:b,directory:c,recursive:d}=a,e=this.getPath(c,b),f=await this.dbRequest("get",[e]);if(void 0===f)throw Error("Folder does not exist.");if("directory"!==f.type)throw Error("Requested path is not a directory");let g=await this.readdir({path:b,directory:c});if(0!==g.files.length&&!d)throw Error("Folder is not empty");for(let a of g.files){let e=`${b}/${a.name}`;"file"===(await this.stat({path:e,directory:c})).type?await this.deleteFile({path:e,directory:c}):await this.rmdir({path:e,directory:c,recursive:d})}await this.dbRequest("delete",[e])}async readdir(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(""!==a.path&&void 0===c)throw Error("Folder does not exist.");let d=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(b)]);return{files:await Promise.all(d.map(async a=>{let c=await this.dbRequest("get",[a]);return void 0===c&&(c=await this.dbRequest("get",[a+"/"])),{name:a.substring(b.length+1),type:c.type,size:c.size,ctime:c.ctime,mtime:c.mtime,uri:c.path}}))}}async getUri(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);return void 0===c&&(c=await this.dbRequest("get",[b+"/"])),{uri:(null==c?void 0:c.path)||b}}async stat(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(void 0===c&&(c=await this.dbRequest("get",[b+"/"])),void 0===c)throw Error("Entry does not exist.");return{name:c.path.substring(b.length+1),type:c.type,size:c.size,ctime:c.ctime,mtime:c.mtime,uri:c.path}}async rename(a){await this._copy(a,!0)}async copy(a){return this._copy(a,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(a,b=!1){let c,{toDirectory:d}=a,{to:g,from:h,directory:i}=a;if(!g||!h)throw Error("Both to and from must be provided");d||(d=i);let j=this.getPath(i,h),k=this.getPath(d,g);if(j===k)return{uri:k};if(function(a,b){a=f(a),b=f(b);let c=a.split("/"),d=b.split("/");return a!==b&&c.every((a,b)=>a===d[b])}(j,k))throw Error("To path cannot contain the from path");try{c=await this.stat({path:g,directory:d})}catch(c){let a=g.split("/");a.pop();let b=a.join("/");if(a.length>0&&"directory"!==(await this.stat({path:b,directory:d})).type)throw Error("Parent directory of the to path is a file")}if(c&&"directory"===c.type)throw Error("Cannot overwrite a directory with a file");let l=await this.stat({path:h,directory:i}),m=async(a,b,c)=>{let e=this.getPath(d,a),f=await this.dbRequest("get",[e]);f.ctime=b,f.mtime=c,await this.dbRequest("put",[f])},n=l.ctime?l.ctime:Date.now();switch(l.type){case"file":{let a,c=await this.readFile({path:h,directory:i});b&&await this.deleteFile({path:h,directory:i}),c.data instanceof Blob||this.isBase64String(c.data)||(a=e.Wi.UTF8);let f=await this.writeFile({path:g,directory:d,data:c.data,encoding:a});return b&&await m(g,n,l.mtime),f}case"directory":if(c)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:g,directory:d,recursive:!1}),b&&await m(g,n,l.mtime)}catch(a){}for(let a of(await this.readdir({path:h,directory:i})).files)await this._copy({from:`${h}/${a.name}`,to:`${g}/${a.name}`,directory:i,toDirectory:d},b);b&&await this.rmdir({path:h,directory:i})}return{uri:k}}isBase64String(a){try{return btoa(atob(a))==a}catch(a){return!1}}}g._debug=!0}};